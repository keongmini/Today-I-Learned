## 다이나믹 프로그래밍(동적계획법)

### 다이나믹 프로그래밍 문제풀이

> 연산속도와 메모리 공간을 최대한 효율적으로 사용하는 것이 중요 -> 하지만, 메모리 공간을 더 사용하면서 연산 속도를 비약적으로 증가할 수 있는 방법  
> 예를들면, 피보나치 수열은 재귀함수로 표현할 수 있지만 구해야하는 값이 커지면 커질수록 수행시간이 기하급수적으로 늘어남 -> 시간복잡도 O(2^n) -> 다이나믹 프로그래밍을 이용하여 효율적으로 해결

* 다이나믹 프로그래밍 조건
  1. 큰 문제를 작은 문제로 나눌 수 있는지
  2. 작은 문제에서 구한 답이 이를 포함한 큰 문제에서도 동일한지
  
* **메모이제이션**: 한번 구한 결과를 메모리 공간에 메모해두고(캐싱) 같은 식을 다시 호출하면 메모한 결과를 그대로 가져다 사용하는 기법

메모이제이션을 이용한 피보나치 수열 구현  -> 시간복잡도 O(n) 
```
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```

> * 퀵정렬은 피벗이 자리를 변경해서 자리를 잡고 나면 해당 해결방식이나 값은 사라짐 <-> 다이나믹 프로그래밍은 이전 연산 내용이 그대로 저장되었다가 다음 연산에도 영향을 줌 

* 다이나믹 프로그래밍 2가지 방식
  1. 탑다운 방식(하향식): 큰 문제 해결을 위해 작은 문제 호출 - 메모이제이션 사용, 결과 저장용 리스트를 'DP리스트'라 함 
  2. 보텀업 방식(상향식): 단순히 반복문을 사용하여 작은 문제부터 하나씩 답 도출 

보텀업 방식으로 피보나치 수열 구현 -> 탑다운 방식보다 약간 빠르지만 큰 차이없음 
```
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

* 다이나믹 프로그래밍 문제인지 확인하기!
  1. 해결해야 하는 문제들의 중복 여부 확인 -> 시간 줄일 수 있는지 확인 
  2. 재귀함수로 구현 후 메모이제이션을 적용하여 코드 개선 
  3. 탑다운 보다는 보텀업 방식을 사용하기 - 'recursion dpth' error 방지를 위해 

참고: 이것이 취업을 위한 코딩테스트다
