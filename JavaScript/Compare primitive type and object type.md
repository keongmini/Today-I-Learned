# 원시 값과 객체 비교
자바스크립트의 7가지 데이터 타입은 원시 타입과 객체 타입으로 구분 가능
- 원시 타입, 변경 불가능한 값 <-> 객체 타입, 변경 가능한 값
- 원시 값을 변수에 할당하면 변수에는 실제 값 저장 <-> 객체를 변수에 할당하면 변수에는 참조 값 저장
- 원시 값의 변수를 다른 변수에 할당하면 원본의 원시 값 복사(값에 의한 전달) <-> 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값 복사(참조에 의한 전달)

## 원시 값
1. 변경 불가능한 값     
   = 한번 생성된 값은 읽기 전용
   - 변수는 언제든지 재할당할 수 있지만 값 자체는 변경할 수 없음 (상수는 재할당이 금지된 **변수** != 변경 불가능한 값)
   - 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간 확보 후 저장, 변수에 새롭게 생성된 값으로 재할당 - 변수가 참조하던 메모리 공간의 주소가 바뀜         
     => 원시 값은 변경 불가능하기 때문에 메모리 주소를 그대로 사용하고 값만 변경할 수 없음     
     => **불변성**
2. 문자열과 불변성      
   - 문자열은 몇 개의 문자로 이뤄졌는지에 따라 필요한 메모리 공간의 크기가 결정됨
   - 문자열은 유사 배열 객체, 이터러블 => 배열처럼 문자에 접근 가능
     > 유사 배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 legth 프로퍼티를 갖는 객체
     > ```javascript
     > var str = 'string';
     >
     > console.log(str[0]);           // s
     > console.log(str.length);       // 6
     > ```
   - 문자열은 원시 값이기 때문에 변경 불가능
     ```javascript
     var str = 'string';

     str[0] = 'S';

     console.log(str);      // string
     ```
3. 값에 의한 전달
   ```javascript
   var score = 80;
   var copy = score;

   console.log(score, copy);      // 80, 80

   console.log(score === copy);   // true
   ```
   위 코드처럼 변수에 변수를 할당하면, score의 값(80)을 보고 새로운 값(80)을 생성하여 copy 변수에 할당        
   = 다른 변수에 원시 값을 갖는 어떤 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값을 복사하여 전달 => 값에 의한 전달
   
   이때, score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값        
   -> 할당 후 변수의 값을 변경해도 다른 변수는 변경 x
   ```javascript
   var score = 80;
   var copy = score;

   score = 100;

   console.log(score, copy);      // 100, 80
   ```

## 객체
정해진 프로퍼티의 개수 x, 동적으로 추가 삭제 가능, 값에 대한 제약 x -> 메모리 공간의 크기 정의 불가

1. 변경 가능한 값
   - 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소(참조 값) 저장, 변수는 참조 값을 통해 객체 접근
   - 원시 값과 달리 객체 변수는 직접 변경이 가능 - 재할당없이 현재 저장되어 있는 메모리 공간의 값 자체를 변경, 삭제, 추가
   - 여러 개의 식별자가 하나의 객체 공유 가능하다는 문제가 있음
   
   > 얕은 복사 / 깊은 복사     
   > 얕은 복사: 한 단계만 복사    
   > 깊은 복사: 중첩되어 있는 객체까지 모두 복사
   > - 얕은 복사, 깊은 복사로 생성된 객체는 원본과 다른 객체 (참조 값이 다른 별개의 객체)
   > - 이때, 얕은 복사는 객체에 중첩되어 있는 객체는 참조 값을 복사 <-> 깊은 복사는 모두 복사해서 원시 값처럼 새로운 값 생성
   >
   > ```javascript
   > const o = {x: {y: 1}};
   >
   > // 얕은 복사
   > const c1 = { ...o };
   > console.log(c1 === o);          // false
   > console.log(c1.x === o.x);      // true
   >
   > // 깊은 복사
   > const _ require('lodash');
   > const c2 = _.cloneDeep(o);
   > console.log(c2 === o);          // false
   > console.log(c2.x === o.x);      // false
   > ```

2. 참조에 의한 전달
   객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달

   ```javascript
   var person = {
     name: 'lee'
   };

   var copy = person;
   ```
   위 코드처럼 원본 person을 사본 copy에 할당하면 둘의 저장된 메모리 주소는 다르지만 동일한 참조 값을 가짐        
   -> 동일한 객체를 가리킨다. = 두 개의 식별자가 하나의 객체를 공유한다.       
   -> 어느 한쪽이 객체를 변경하면 서로 영향을 받음
