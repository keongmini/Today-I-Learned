# 함수
일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

함수 외부 -> 함수 내부: 매개변수(입력으로 전달받는 변수), 인수(입력)         
함수 내부 -> 함수 외부: 반환값(출력)

* 함수 생성 = 정의
  ```javascript
  function add(x,y) {
    return x + y;
  }
  ```

* 함수 호출: 매개변수를 통해 인수를 함수에 전달 = 함수의 실행을 명시적으로 지시     
           함수 호출 후 코드블록에 담긴 문들이 일괄적 실행, 실행 결과(반환값) 반환
  ```javascript
  var result = add(2, 5);

  console.log(result);          // 7
  ```

* 함수를 사용하는 이유
  - 코드의 재사용: 같은 코드를 중복해서 작성하지 않고 미리 정의된 함수를 통해 여러번 재사용 가능
  - 유지보수의 편의성, 코드의 신뢰성: 코드의 중복을 억제하고 재사용성을 높여 실수와 코드 수정 시간을 단축
  - 코드의 가독성: 객체 타입인 함수에 이름(식별자)를 붙여 함수의 역할 파악

* 함수 리터럴      
  function 키워드 + 함수 이름 + 매개변수 목록 + 함수 몸체 로 구성
  - 함수 이름
      - 함수 몸체 내에서만 참조할 수 있는 식별자
      - 이름 생략 가능(기명/무명(익명) 함수)
  - 매개변수 목록
      - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
      - 매개변수에는 호출할 때 지정한 인수가 순서대로 할당
      - 매개변수는 몸체 내에서 변수와 동일하게 취급
  - 함수 몸체
      - 함수 호출 시 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
      - 함수 호출에 의해 실행

  함수 리터럴이 평가되면 값을 생성하고 값은 객체 = 함수는 객체이다.     
  이때, 일반객체는 호출할 수 없지만 함수는 호출할 수 있다, 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.


## 함수 정의
- 함수를 호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것
- 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨

### [함수를 정의하는 4가지 방식]

1. 함수 선언문
   ```
   function add(x, y){
     return x + y;
   }

   console.log(add(2, 5));      // 7
   ```
   - 함수 리터럴과 동일한 형태
   - 함수 이름 생략 불가 <-> 함수 리터럴은 이름 생략 가능
   - 선언문은 표현식이 아닌 문 -> 함수 선언문 실행시 완료값 undefined 출력
   - 변수에 할당 불가
  
   [함수 선언문과 리터럴]
   ```javascript
   var add = function add(x, y){
     return x + y;
   }
   ```
   위 코드는 함수 선언문이 변수에 할당 가능한 것처럼 보임     
   { }이 단독으로 존재하면 블록문 / 피연산자로 사용(기명 함수 리터럴 포함)되면 객체 리터럴로 해석 -> 코드 문맥에 따라 해석이 달라짐    
   -> 함수 선언문과 함수 리터럴 표현식의 함수 생성 방식은 동일 하지만 내부 동작에 차이가 있음
   ```javascript
   function foo() { console.log('foo');  }
   // 함수 선언문으로 해석

   (function bar(){ console.log('bar'); });
   // 함수 리터럴 표현식으로 해석
   ```
   단독으로 사용된 함수 리터럴(foo)은 함수 선언문으로 해석 <-> 그룹 연산자( ) 내 함수 리터럴(bar)은 함수 리터럴 표현식으로 해석    
   -> 기명 함수 리터럴은 함수 선언문 or 함수 리터럴 표현식으로 해석 가능
   
   둘의 객체 생성은 동일하지만 함수 선언문은 호출 가능 <-> 함수 리터럴은 호출 불가   
   - 함수 리터럴의 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 - 외부에서는 함수 이름으로 함수 호출 불가 = 함수를 가리키는 식별자가 없음
   - foo는 식별자를 선언하거나 할당한 적이 없지만 자바스크립트 엔진이 암묵적으로 생성한 식별자 -> 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체 할당
     ```javascript
     var add = function add(x, y){
       return x + y;
     }
     ```
     내부적으로 위와 같이 작동 - 자바스크립트 엔진이 암묵적으로 생성한 식별자(add)를 통해 함수 선언문으로 생성한 함수 호출(함수 이름으로 호출 x)

2. 함수 표현식    
   함수는 일급객체 - 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 방식: 함수 표현식
   
   > 일급 객체: 값의 성질을 갖는 객체 = 함수를 값처럼 자유롭게 사용 가능, 자바스크립트의 함수는 일급 객체이다.

   ```javascript
   var add = function (x, y) {
     return x + y;
   }

   console.log(add(2, 5));      // 7
   ```
   - 함수 표현식의 함수 리터럴은 일반적으로 익명 함수(이름 생략)
   - 함수 표현식: 표현식인 문 <-> 함수 선언문: 표현식이 아닌 문

    #### 함수 생성 시점과 함수 호이스팅
    ```javascript
    console.log(add(2, 5));        // 7
    console.log(sub(2, 5));        // TypeError: sub is not a function
    
    // 함수 선언문
    function add(x, y) {
      return x + y;
    }
    
    // 함수 표현식
    var sub = function(x, y){
      return x - y;
    }
    ```
    함수 선언문 - 정의 이전에 호출 가능 <-> 함수 표현식 - 정의 이전에 호출 불가      
    -> 둘의 생성 시점이 다름
      - 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행 = 함수 객체 먼저 생성 후 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수 객체 할당       
        => **호이스팅**      
          > 변수 호이스팅: 자바스크립트 엔진에 의해 먼저 선언 후 undefined로 초기화        
          > 함수 호이스팅: 먼저 선언 후 함수 선언문으로 정의함 함수를 함수 객체로 초기화
      - 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문 -> 변수 선언은 런타임 이전에 실행되어 undefined로 초기화 후 런타임에 함수 리터럴 할당        
        -> 변수 호이스팅 실행

3. Function 생성자 함수      
   자바스크립트에서 제공하는 빌트인 함수 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하여 new 연산자와 함께 호출하면 함수 객체 생성 후 반환
   ```javascript
   var add = new Function('x', 'y', 'return x + y');
   
   console.log(add(2, 5));        // 7
   ```
   - 함수 선언문과 함수 표현식으로 생성한 함수와는 다르게 동작
   - 클로저 생성하지 않음 (추후 학습 예정)

4. 화살표 함수      
   function 키워드 대신 화살표(=>)를 사용해서 간략하게 함수 선언, 익명 함수로 정의
   ```javascript
   const add = (x, y) => x + y;
   console.log(add(2, 5));            // 7
   ```
   기존의 함수보다 내부 동작 간략화 - 생성자 함수로 사용 불가, this 바인딩 방식 다름, prototype 프로퍼티 없음, arguments 객체 생성하지 않음
   (추후 학습 예정)
