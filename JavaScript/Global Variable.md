# 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수
전역 변수의 선언은 런타임 이전에 가장 먼저 실행 됨 <-> 함수 내부에서 선언한 지역 변수는 함수가 호출된 후 함수 몸체의 코드가 실행되기 전에 먼저 실행

```javascript
function foo() {
  var x = 'local';
  console.log(x);
  return x;
}

foo();
```
foo 함수 호출 -> x 변수 선언, undefined로 초기화 -> 코드를 순차적으로 진행하면서 x 변수에 값 할당 -> 함수 종료 시 x 변수 소멸(생명 주기 종료)         
=> **지역 변수의 생명 주기 = 함수의 생명 주기**

```javascript
var x = 'global'

function foo() {
  console.log(x);            // undefined
  var x = 'local';
}

foo();
```
호이스팅은 스코프 단위로 동작


### 전역 변수
함수와 달리 명시적인 호출없이 코드가 로드되자마자 바로 해석 후 실행, 더 이상 실행할 문이 없을 때 종료

var 키워드로 선언한 전역변수는 전역 객체의 프로퍼티 => 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치
> 전역 객체: 코드가 실행되기 이전에 자바스크립트 엔진에 의해 어떤 객체 보다도 먼저 생성되는 특수 객체


## 전역 변수의 문제점
1. 암묵적 결합      
   전역 변수는 코드 어디서든 참조하고 할당할 수 있는 변수 = 모든 코드가 전역변수를 참조하고 변경할 수 있는 암묵적 결합 허용      
   -> 변수의 유효범위가 커질수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있음

2. 긴 생명주기        
   전역변수의 생명주기는 길다 -> 메모리 리소스도 오랜 기간 소비 -> 전역 변수의 상태를 변경할 수 있는 시간과 기회가 많음

3. 스코프 체인 상에서 종점에 존재       
   변수를 검색할 때 전역 변수가 가장 마지막에 검색됨 = 전역 변수의 검색 속도가 가장 느림

4. 네임스페이스 오염
   하나의 파일이 분리되어있어도 하나의 전역 스코프 공유


## 전역 변수의 사용을 억제하는 방법
1. 즉시 실행 함수        
   함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출 -> 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
   ```javascript
   (function () {
     var foo = 10;
   }());
   ```
   전역 변수를 생성하지 않기 때문에 라이브러리 등에 자주 사용

1. 네임스페이스 객체        
   전역에 네임 스페이스 역할을 담당하는 객체 생성, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
   ```javascript
   var MYAPP = {};
   
   MYAPP.name = 'Lee';

   MYAPP.person = {
     name: 'Lee',
     address: 'Seoul'
   };
   ```
   네임 스페이스 분리를 통해 식별자 충돌 방지는 가능하지만 네인스페이스 자체가 전역 변수에 할당되기 때문에 유용하지 않음

1. 모듈 패턴       
   관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감사 하나의 모듈 생성
   - 클로저 기반 동작
   - 전역 변수 억제 + 캡슐화 구현 가능
     > 캡슐화: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶은 것     
     > 객체의 특정 프로퍼티나 메서드를 감출 목적으로 캡슐화를 사용하는 것 = 은닉

     대부분 객체지향 언어는 클래스에 ```public, private, proteced``` 등의 접근 제한자를 통해 공개 범위 한정
     - public: 데이터, 메소드 외부에서 접근 가능
     - private: 외부에서 접근 불가, 내부에서만 접근 가능
     => 클래스 외부에는 제한된 접근 권한을 제공, 내부 보호

     자바스크립트에서는 접근 제한자를 제공하지 않음 -> 모듈 패턴을 통해 정보 은닉 구현
     ```javascript
     var Counter = (function () {
       var num = 0;

       return {
         increase() {
           return ++num;
         },
         decrease() {
           return --num;
         }
       }
     }());

     console.log(Counter.num);       // undefined

     console.log(Counter.increase());      // 1
     console.log(Counter.increase());      // 2
     console.log(Counter.decrease());      // 1
     console.log(Counter.decrease());      // 0
     ```
     위 코드에서 즉시 실행 함수는 객체 반환 - 외부에 노출하고 싶은 변수나 함수를 객체에 담아 반환
     - 이때 반환되는 객체의 프로퍼티가 외부에 노출되는 **퍼블릭 멤버**
     - 외부로 노출하고 싶지 않은 변수나 함수는 반환 객체에 추가 x - 외부에서 접근 불가 **프라이빗 멤버**

1. ES6 모듈        
   파일 자체의 독자적인 모듈 스코프 제공 - 전역 변수 사용 불가
   - 모듈 내에서 var 키워드로 선언한 변수 - 전역 변수 x, window 객체의 프로퍼티 x
   - script 태그 내에 ```type='module'``` 속성 추가 시 자동으로 모듈로 동작, 모듈의 파일 확장자 mjs 권장
     ```html
     <script type='module' src='app.mjs'></script>
     ```
   
