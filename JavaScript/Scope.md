# 스코프
식별자가 유효한 범위

- 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위 결정
- 식별자 결정: 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조할지 결정 - 스코프에 의해 결정 = 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙
  > 렉시컬 환경: 코드가 어디서 실행되고 주변에 어떤 코드가 있는지    
  > 문맥은 렉시컬 환경으로 이뤄짐     
  > -> '실행 컨텍스트' 

```javascript
var x = 'global';        // 1

function foo() {
  var x = 'local';      // 2
  console.log(x);
}

console.log(x);
```
위 코드에서 같은 이름(x)의 변수를 두번 선언
  - 1번 변수는 가장 바깥에 선언됐기 때문에 어디서든 참조 가능
  - 2번 변수는 함수 내부에 선언됐기 때문에 함수 내부에서만 참조 가능
-> 두 변수는 스코프가 다른 별개의 변수

- 식별자는 어떤 값을 구별할 수 있어야 하기 때문에 유일해야 함    
  이때, 식별자가 위치한 지점이 다르면 됨(다른 폴더에 위치) - 식별자의 출돌 방지 => 스코프 = 네임스페이스

  > var는 중복 선언 허용 <-> let, const는 중복 선언 불가

## 스코프 종류
- 전역: 코드의 가장 바깥에 선언된 변수, 전역 스코프를 갖음 - 어디서든 참조 가능
- 지역: 함수 몸체 내부에 선언된 변수, 지역 스코프를 갖음 - 자신의 지역 스코프와 하위 지역 스코프에서만 유효

이름이 같은 전역 변수와 함수 내에 지역 변수가 있다면 함수 내부에서 변수 호출시 지역 변수 참조 -> 자바스크립트 엔진이 스코프 체인을 통해 참조 변수를 검색했기 때문

## 스코프 체인
스코프가 계층적으로 연결된 것

- 함수는 함수 몸체 내부에서도 정의할 수 있음(함수의 중첩)
- 함수의 지역 스코프도 중첩 가능 => 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.       
  => 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부 함수의 지역 스코프 = 중첩 함수의 상위 스코프
  ```javascript
  var x = 'global x';
  var y = 'global y';

  function outer() {
    var z = 'outer local z';
  
    function inner() {
      var x = 'inner local x';
    }

    inner();
  }

  outer();
  ```
  - 위 코드에서 inner 함수는 outer 함수의 중첩 함수
  - outer 함수가 만든 지역 스코프는 inner 함수가 만든 지역 스코프의 상위 스코프
  - outer 함수의 지역 스코프의 상위 스코프는 전역 스코프       
  => 모든 스코프가 하나의 계측적 구조로 연결, 모든 지역 스코프의 최상위 스코프는 전역 스코프
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색
- 자바스크립트 엔진은 코드를 실행하기 전에 렉시컬 환경을 실제로 생성 - 변수 선언이 실행되면 변수 식별자가 이 자료구조(렉시컬 환경)에 키로 등록, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값 변경

1. 변수 검색     
   위 코드에서 inner 함수에서 x 변수 호출하면 inner 함수의 지역 스코프에서 x 변수가 선언되었는지 먼저 검색 - 있으면 검색 종료    
   y 변수를 호출하면 inner 함수의 지역 스코프에 있는지 검색 - 없으면 상위 스코프인 outer 함수에서 검색 - 없으면 전역 스코프에서 검색 - 발견 후 종료      
   
   - 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능, 하위스코프에서 유효한 변수를 상위 스코프에서 참조 불가
   - 스코프 체인으로 연결된 스코프의 계층적 구조는 상속과 유사

2. 함수 검색
   ```javascript
   function foo() {
     console.log('global function');
   }

   function bar() {
     function foo() {
       console.log('local function');
     }

     foo();
   }

   bar();
   ```
   식별자에 함수 객체가 할당된 것 외에 일반 변수와 동일

## 함수 레벨 스코프
지역은 함수 몸체 내부를 의미 => 코드 블록이 아닌 함수에 의해서만 지역 스코프 생성           
var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정 - 함수 레벨 스코프

> 블록 레벨 스코프: 함수 몸체 뿐만 아니라 코드 블록이 지역 스코프를 생성

```javascript
var x = 1;

if (true) {
  var x = 10;
}

console.log(x);        // 10
```
var 키워드는 함수 레벨 스코프만 인정하기 때문에 코드 블록 내에서 var 키워드로 선언한 변수는 모두 전역 변수임 -> 전역 변수 중복 선언 + 재할당 수행

> ES6의 let, const 키워드는 블록 레벨 스코프 지원

## 렉시컬 스코프
```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar(){
  console.log(x);
}

foo();
bar();
```

[상위 스코프 결정 방식]
  1. 함수를 어디서 **호출**했는지: 동적 스코프 (함수가 어디서 호출되는지 알 수 없기 때문에 호출될 때 동적으로 스코프 결정)
  2. 함수를 어디서 **정의**했는지: 렉시컬 스코프, 정적 스코프 (함수 정의가 평가되는 시점에 정적으로 결정)

대부분의 프로그래밍언어에서는 렉시컬 스코프 사용 - 함수가 호출된 위치는 아무런 영향도 주지 않음, 함수의 상위 스코프는 자신이 정의된 스코프

렉시컬 스코프에 따라서 위 코드에서 bar함수는 전역에서 정의된 함수
  - 함수 선언문으로 정의된 bar함수는 전역 코드가 실행되기 전에 먼저 평가되어 함수 객체 생성
  - 이때 생성된 bar함수는 자신이 정의된 스코프 = 전역 스코프 기억
  - bar함수가 호출되면 호출된 위치와 상관없이 기억하고 있는 전역 스코프를 상위 스코프로 사용       
  => 위코드에서는 x의 값 1을 두번 출력







