# 변수

표현식에 대해 연산하고 연산이 끝난 후 결과를 메모리에 저장했지만 재사용할 수 가 없음

* 변수: 재사용을 위해 하나의 값을 저장하기 위한 메모리 공간 자체(메모리 공간을 식별하기 위한 이름) - 값의 위치를 가리키는 이름   
(메모리 주소를 통해 직접 접근하게 되면 시스템이 중단될 수 도 있는 치명적인 문제 발생 가능성이 있음 -> 자바스크립트는 개발자의 직접적인 메모리 접근 비허용)

> 여러개의 값을 저장하는 방법: 여러개의 변수 사용, 배열 또는 객체같은 자료구조 이용해서 그룹화

변수 이름 (메모리 공간에 저장된 값을 식별할 수 있는 고유의 이름) = 변수 값 (변수에 저장된 값)

**할당** (대입, 저장) : 변수에 값 저장 <-> **참조**: 변수 값 읽기

> 데이터를 기억하는 메모리: 데이터를 저장할 수 있는 메모리 셀의 집합체
> - 메모리 셀 하나의 크기 1바이트
> - 메모리 셀 단위로 데이터를 저장하고 읽음
> - 각 셀은 고유의 메모리 주소(= 메모리 공간 위치)를 가짐
> - 메모리에 저장되는 모든 데이터는 2진수로 처리

## 식별자

변수이름을 식별자라고도 함

= 변수 이름, 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별하기 위해 값이 저장되어 있는 메모리 주소를 기억해야 함 => **식별자는 값이 아닌 메모리 주소를 기억** (메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미)
  - 변수, 함수, 클래스 등의 이름 모두 식별자 => 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름
  - 선언을 통해 자바스크립트 엔진에 식별자의 존재를 알림

## 변수 선언
= 변수 생성, 값을 저장하기 위한 메모리 공간 확보하고 변수 이름과 확보된 메모리 공간의 주소 연결해서 값 저장할 수 있게 준비
  - 선언에 의해 확보된 공간은 해제되기 전까지 보호되므로 안전
  - 변수 선언시 **var, let, const** 사용
      > ES5와 ES6 차이점: let, const 존재여부  
      > var의 단점: 블록 레벨 스코프 지원x - 의도하지 않게 전역 변수가 선언되어 문제 발생  
      > => 이를 해결하기 위헤 ES6에서 let, const 도입

  * var   
    ```var score``` 로 변수 선언시
      - 변수 이름 등록
      - 저장할 메모리 공간 확보
      - 값은 할당되지 않았기 때문에 메모리 공간은 비어있고 **undefined**로 할당되어 초기화됨
        => var를 통한 변수 선언 = 선언 단계 + 초기화 단계 동시에 진행

        > 모든 식별자는 실행 컨택스트에 등록   
        > 실행 컨택스트: 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경 제공, 실행 결과를 관리
   
        > 변수를 사용하려면 반드시 선언이 필요!     
        > ```ReferenceError(참조에러)```   
        > 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
        
## 변수 선언의 실행 시점과 호이스팅
변수 선언은 런타임(소스코드가 한줄씩 순차적으로 실행되는 시점)이 아닌 이전 단계에서 먼저 실행 -> 변수 선언 전에 변수를 참조하는 코드가 있어도 에러 발생하지 않고 정상 실행됨

=> 자바스크립트 엔진은 변수 선언이 다른 코드보다 먼저 실행됨! => **호이스팅** (변수 선언이 선두로 올려진 것처럼 동작하는 JS 고유 특징)


## 값의 할당
= 대입, 저장
- 할당 연산자 사용

주의! 변수 선언과 값의 할당 실행 시점이 다름
- 변수 선언 = 런타임 이전에 실행
- 값의 할당 = 런타임에 실행  
(변수 선언과 값의 할당을 한문장으로 표현해도 따로 실행됨)

undefined와 다른 메모리공간 확보하여 할당


## 값의 재할당
이미 값이 할당되어 있는 변수에 다른 값을 다시 할당

<-> 상수: 값을 재할당할 수 없어서 저장된 값을 변경할 수 없음

var, let은 가능, const는 불가능

값을 재할당하게 되면 새로운 메모리 공간을 확보해서 그 공간에 값을 저장 - 이전 값은 기억하지 않음, 가비지 콜렉터에 의해 메모리에서 자동 해제

> 가비지 콜렉터: 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해서 더이상 사용하지 않는 메모리를 해제하는 기능

> 언매니지드 vs 매니지드   
> 언매니지드 언어: 개발자가 주도적으로 메모리 할당하고 해제    
> 매니지드 언어: 언어 차원에서 메모리 할당과 해제 담당, 개발자가 직접적으로 메모리 제어하지 않음

## 식별자 네이밍 규칙
1. 특수문자 x, 문자, 숫자, 언더바, 달러 기호 포함 가능
2. 숫자로 시작 x
3. 예약어는 식별자로 사용 불가
4. 자바스크립트에서는 일반적으로 변수, 함수 이름: 카멜 케이스 / 생성자 함수, 클래스 이름: 파스칼 케이스 사용

SyntaxError 발생

