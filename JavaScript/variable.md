# 변수

* 변수: 재사용을 위해 하나의 값을 저장하기 위한 메모리 공간 자체(메모리 공간을 식별하기 위한 이름) - 값의 위치를 가리키는 이름   
(메모리 주소를 통해 직접 접근하게 되면 시스템이 중단될 수 도 있는 치명적인 문제 발생 가능성이 있음 -> 자바스크립트는 개발자의 직접적인 메모리 접근 비허용)

**할당**: 변수에 값 저장 <-> **참조**: 변수 값 읽기

> 데이터를 기억하는 메모리: 데이터를 저장할 수 있는 메모리 셀의 집합체
> - 메모리 셀 하나의 크기 1바이트
> - 메모리 셀 단위로 데이터를 저장하고 읽음
> - 각 셀은 고유의 메모리 주소(= 메모리 공간 위치)를 가짐
> - 메모리에 저장되는 모든 데이터는 2진수로 처리

## 식별자
= 변수 이름, 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별하기 위해 값이 저장되어 있는 메모리 주소를 기억해야 함 => **식별자는 값이 아닌 메모리 주소를 기억**
  - 변수, 함수, 클래스 등의 이름 모두 식별자

## 변수 선언
= 변수 생성, 값을 저장하기 위한 메모리 공간 확보하고 변수 이름과 확보된 메모리 공간의 주소 연결해서 값 저장
  - 변수 선언시 **var, let, const** 사용
      > ES5와 ES6 차이점: let, const 존재여부  
      > var의 단점: 블록 레벨 스코프 지원x - 의도하지 않게 전역 변수가 선언되어 문제 발생  
      > => 이를 해결하기 위헤 ES6에서 let, const 도입

  * var   
    ```var score``` 로 변수 선언시
      - 변수 이름 등록
      - 저장할 메모리 공간 확보
      - 값은 할당되지 않았기 때문에 메모리 공간은 비어있고 **undefined**로 할당되어 초기화됨
        => var를 통한 변수 선언 = 선언 단계 + 초기화 단계 동시에 진행

        > 모든 식별자는 실행 컨택스트에 등록   
        > 실행 컨택스트: 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경 제공, 실행 결과를 관리
        
        > ```ReferenceError(참조에러)```   
        > 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
        
## 변수 선언의 실행 시점과 호이스팅
변수 선언은 런타임(소스코드가 한줄씩 순차적으로 실행되는 시점)이 아닌 이전 단계에서 먼저 실행 -> 변수 선언 전에 변수를 참조하는 코드가 있어도 에러 발생하지 않고 정상 실행됨

=> 자바스크립트 엔진은 변수 선언이 다른 코드보다 먼저 실행됨! => **호이스팅**


## 값의 할당
= 대입, 저장

주의! 변수 선언과 값의 할당 실행 시점이 다름
- 변수 선언 = 런타임 이전에 실행
- 값의 할당 = 런타임에 실행  
(변수 선언과 값의 할당을 한문장으로 표현해도 따로 실행됨)


## 값의 재할당
이미 값이 할당되어 있는 변수에 다른 값을 다시 할당

var, let은 가능, const는 불가능

값을 재할당하게 되면 새로운 메모리 공간을 확보해서 그 공간에 값을 저장 - 이전 값은 기억하지 않음, 가비지 콜렉터에 의해 메모리에서 자동 해제

> 가비지 콜렉터: 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해서 더이상 사용하지 않는 메모리를 해제하는 기능

> 언매니지드 vs 매니지드   
> 언매니지드 언어: 개발자가 주도적으로 메모리 할당하고 해제    
> 매니지드 언어: 언어 차원에서 메모리 할당과 해제 담당, 개발자가 직접적으로 메모리 제어하지 않음

## 식별자 네이밍 규칙
1. 특수문자 x, 문자, 숫자, 언더바, 달러 기호 포함 가능
2. 숫자로 시작 x
3. 예약어는 식별자로 사용 불가
4. 자바스크립트에서는 일반적으로 변수, 함수 이름: 카멜 케이스 / 생성자 함수, 클래스 이름: 파스칼 케이스 사용



